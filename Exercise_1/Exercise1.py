# -*- coding: utf-8 -*-
"""AI_Exercises

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bILxw0TbBj5UJDsdflkN7bPekAqPjqYS

#Problem#
"""

import numpy as np
import math


maze_Initial_state = [15,1]
maze_Goal_state = [15,29]


maze = np.array([[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
             [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1],
             [1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,0,1],
             [1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1],
             [1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1],
             [1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,1],
             [1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1],
             [1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,1],
             [1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1],
             [1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1],
             [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1],
             [1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1],
             [1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,1,1,1,1],
             [1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1],
             [1,0,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
             [1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,2,1],
             [1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,1],
             [1,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1],
             [1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,0,1],
             [1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1],
             [1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1],
             [1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1],
             [1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1],
             [1,0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1],
             [1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1],
             [1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,1],
             [1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,0,1,0,1],
             [1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1],
             [1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1],
             [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
             [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]])


simple_maze_Initial_state = [3,1]
simple_maze_Goal_state = [3,3]

simple_maze = np.array([[1,1,1,1,1],
                        [1,0,0,0,1],
                        [1,0,1,0,1],
                        [1,0,1,0,1],
                        [1,1,1,1,1]])
two_path_maze_Initial_state = [5,1]
two_path_maze_Goal_state = [1,11]

two_path_maze = np.array([[1,1,1,1,1,1,1,1,1,1,1,1,1],
                          [1,0,0,0,0,0,0,0,0,0,0,0,1],
                          [1,0,1,1,1,1,1,1,1,1,1,0,1],
                          [1,0,0,0,0,0,1,0,0,0,0,0,1],
                          [1,1,0,0,1,0,1,0,1,0,1,1,1],
                          [1,0,0,0,1,0,0,0,1,0,0,0,1],
                          [1,1,1,1,1,1,1,1,1,1,1,1,1]])

class problem:
  def __init__(self, maze, Initial_state, Goal_state):
    self.Initial_state = Initial_state
    self.Goal_state = Goal_state
    self.maze = maze

  def Action(self, State):
    maze = self.maze
    Acts = []
    r = State[0]
    c = State[1]
    if maze[r+1][c] == 0: Acts.append('Down')
    if maze[r-1][c] == 0: Acts.append('Up')
    if maze[r][c+1] == 0: Acts.append('Right')
    if maze[r][c-1] == 0: Acts.append('Left')
    return Acts
  
  def Result(self, parent_node, action):
    Child_state = ()
    Parent_state = parent_node.State
    row = Parent_state[0]
    col = Parent_state[1]
    if action == 'Down': Child_state = [row+2, col]
    if action == 'Up': Child_state = [row-2, col]
    if action == 'Right': Child_state = [row, col+2]
    if action == 'Left': Child_state = [row, col-2]
    return Child_state
  
  def Step_cost(self, state= None, action= None):
    #Cost is not defined
    return 1

  def Goal_test(self, node):
    state = node.State
    if state[0] == self.Goal_state[0] and state[1] == self.Goal_state[1]:
      return True
    else: 
      return False

class Node:
  def __init__(self, State, cost, depth, parent_action= None, Parent= None, f= None):
    self.State = State
    self.Parent = Parent
    self.cost = cost
    self.depth = depth
    self.parent_action = parent_action
    self.f = f

  def __str__(self):
    row = self.State[0] 
    col = self.State[1]
    show = '[' + str(row) + ',' + str(col) + ']'
    return show
  
  def __repr__(self):
    row = self.State[0] 
    col = self.State[1]
    show = '[' + str(row) + ',' + str(col) + ']'
    return show
  
  def __lt__(self, other):   # define "<" 
        return (self.depth < other.depth)

  def Set_f(self,f):
    self.f = f
  
  def equal(self,node):
    if self.State == node.State:
      return True
    else: 
      return False

  def exist_in(self, frontier, frontier_type= None):
    if frontier_type == 'heapq':
      for tup in frontier:
        if self.equal(tup[1]):
          return True
      return False
    if len(frontier) == 0:
      return False
    else:
      for nodes in frontier:
        if self.equal(nodes):
          return True
      return False
  def Solution(self):
    S = []
    S_reverse = []
    depth = self.depth - 1
    for i in range(depth, -2, -1):  
      S.append(self)
      self = self.Parent
    S.reverse()
    return S



def Child_node(problem, parent, action):
  state = problem.Result(parent, action)
  cost = parent.cost + problem.Step_cost()
  depth = parent.depth + 1
  child = Node(state, cost, depth, action, parent)
  return child

"""#Exercise 1

##Exercise 1.1
"""

def BFS(problem):

  node = Node(problem.Initial_state, 0, 0)
  if problem.Goal_test(node) : return node.State
  frontier = [node]
  explored = []
  while True:
    if len(frontier) == 0 : 
      return "failure"
    node = frontier.pop(0) #POP
    print('POP:')
    print(node)
    print("__________________________________________________________________________________________________________________________________")
    explored.append(node.State)
    for action in problem.Action(node.State):
      child = Child_node(problem, node, action)
      if child.State not in explored and not child.exist_in(frontier):
        if problem.Goal_test(child):
          print("PATH")
          s = child.Solution()
          return s
        frontier.append(child) #PUSH
      print("EXPLORED:")
      print(explored)
      print("__________________________________________________________________________________________________________________________________")
      print("FRONTIER:")
      print(frontier)
      print("__________________________________________________________________________________________________________________________________")

prob = problem(maze, maze_Initial_state, maze_Goal_state) #(31*31)
# if you want test on simple maze(5*5) uncomment the following line
#prob = problem(simple_maze, simple_maze_Initial_state, simple_maze_Goal_state)
s = BFS(prob)
print(s)

"""##Exercise 1.2"""

def Depth_limit_search(problem, limit= 10):
  node = Node(problem.Initial_state, 0, 0)
  return Recursive_DLS(node, problem, limit)

def Recursive_DLS(node, problem, limit):
  if problem.Goal_test(node): return node.Solution()
  elif limit == 0: return "cutoff"
  else:
    cutoff_occurred = False
    for action in problem.Action(node.State):
      child = Child_node(problem, node, action)
      print(child)
      result = Recursive_DLS(child, problem, limit - 1)
      if result == "cutoff": 
        cutoff_occurred = True
      elif not result == "failure": return result
    if cutoff_occurred: return "cutoff" 
    else: return "failure"

def Iterative_deeping_search(problem):
  for depth in range(0, 10**10000):
    print("LIMIT: ",depth)
    result = Depth_limit_search(problem, depth)
    print("__________________________________________________________________________________________________________________________________")
    if result != "cutoff":
      return result

prob = problem(simple_maze, simple_maze_Initial_state, simple_maze_Goal_state) #(5*5)
#if you want test on maze(31*31) uncomment the following line
#prob= problem(maze, maze_Initial_state, maze_Goal_state)
Iterative_deeping_search(prob)