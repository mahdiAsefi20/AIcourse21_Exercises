# -*- coding: utf-8 -*-
"""AI_Exercise2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G3_KQ9lBHwLJAtLiE90lpWlaLJAr-Vmd

#Problem#
"""

import numpy as np
import math


maze_Initial_state = [15,1]
maze_Goal_state = [15,29]


maze = np.array([[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
             [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1],
             [1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,0,1],
             [1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1],
             [1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1],
             [1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,1],
             [1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1],
             [1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,1],
             [1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1],
             [1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1],
             [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1],
             [1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1],
             [1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,1,1,1,1],
             [1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1],
             [1,0,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
             [1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,2,1],
             [1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,1],
             [1,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1],
             [1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,0,1],
             [1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1],
             [1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1],
             [1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1],
             [1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1],
             [1,0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1],
             [1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1],
             [1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,1],
             [1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,0,1,0,1],
             [1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1],
             [1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1],
             [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
             [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]])


simple_maze_Initial_state = [3,1]
simple_maze_Goal_state = [3,3]

simple_maze = np.array([[1,1,1,1,1],
                        [1,0,0,0,1],
                        [1,0,1,0,1],
                        [1,0,1,0,1],
                        [1,1,1,1,1]])
two_path_maze_Initial_state = [5,1]
two_path_maze_Goal_state = [1,11]

two_path_maze = np.array([[1,1,1,1,1,1,1,1,1,1,1,1,1],
                          [1,0,0,0,0,0,0,0,0,0,0,0,1],
                          [1,0,1,1,1,1,1,1,1,1,1,0,1],
                          [1,0,0,0,0,0,1,0,0,0,0,0,1],
                          [1,1,0,0,1,0,1,0,1,0,1,1,1],
                          [1,0,0,0,1,0,0,0,1,0,0,0,1],
                          [1,1,1,1,1,1,1,1,1,1,1,1,1]])

class problem:
  def __init__(self, maze, Initial_state, Goal_state):
    self.Initial_state = Initial_state
    self.Goal_state = Goal_state
    self.maze = maze

  def Action(self, State):
    maze = self.maze
    Acts = []
    r = State[0]
    c = State[1]
    if maze[r+1][c] == 0: Acts.append('Down')
    if maze[r-1][c] == 0: Acts.append('Up')
    if maze[r][c+1] == 0: Acts.append('Right')
    if maze[r][c-1] == 0: Acts.append('Left')
    return Acts
  
  def Result(self, parent_node, action):
    Child_state = ()
    Parent_state = parent_node.State
    row = Parent_state[0]
    col = Parent_state[1]
    if action == 'Down': Child_state = [row+2, col]
    if action == 'Up': Child_state = [row-2, col]
    if action == 'Right': Child_state = [row, col+2]
    if action == 'Left': Child_state = [row, col-2]
    return Child_state
  
  def Step_cost(self, state= None, action= None):
    #Cost is not defined
    return 1

  def Goal_test(self, node):
    state = node.State
    if state[0] == self.Goal_state[0] and state[1] == self.Goal_state[1]:
      return True
    else: 
      return False

class Node:
  def __init__(self, State, cost, depth, parent_action= None, Parent= None, f= None):
    self.State = State
    self.Parent = Parent
    self.cost = cost
    self.depth = depth
    self.parent_action = parent_action
    self.f = f

  def __str__(self):
    row = self.State[0] 
    col = self.State[1]
    show = '[' + str(row) + ',' + str(col) + ']'
    return show
  
  def __repr__(self):
    row = self.State[0] 
    col = self.State[1]
    show = '[' + str(row) + ',' + str(col) + ']'
    return show
  
  def __lt__(self, other):   # define "<" 
        return (self.depth < other.depth)

  def Set_f(self,f):
    self.f = f
  
  def equal(self,node):
    if self.State == node.State:
      return True
    else: 
      return False

  def exist_in(self, frontier, frontier_type= None):
    if frontier_type == 'p_Q':
      for tup in frontier:
        if self.equal(tup[1]):
          return True
      return False
    if len(frontier) == 0:
      return False
    else:
      for nodes in frontier:
        if self.equal(nodes):
          return True
      return False
  def Solution(self):
    S = []
    S_reverse = []
    depth = self.depth - 1
    for i in range(depth, -2, -1):  
      S.append(self)
      self = self.Parent
    S.reverse()
    return S



def Child_node(problem, parent, action):
  state = problem.Result(parent, action)
  cost = parent.cost + problem.Step_cost()
  depth = parent.depth + 1
  child = Node(state, cost, depth, action, parent)
  return child

"""#Exercise 2

"""

def Euclidean_heuristic(problem,node):  #returrn Euclidean distance
  x_goal = problem.Goal_state[0]
  y_goal = problem.Goal_state[1]

  x_node = node.State[0]
  y_node = node.State[1]

  x_dis = (x_goal - x_node) / 2 #Divided into two: Because of the walls in the matrix
  y_dis = (y_goal - y_node) / 2
 
  Euc_dis = math.sqrt((x_dis**2) + (y_dis**2))

  return Euc_dis


def F(problem, node, Strategy= None):
  if Strategy == 'A_star':
    g = node.cost
    h = Euclidean_heuristic(problem, node)
    f = g + h
    return f #int

  else:
   f = node.cost
   return f #int

def Replace(frontier, node):
  for t in frontier:
    if t[1].equal(node):
      if t[1].f >= node.f:
       t = (node.f,node)
       print("__________________Replace__________________Replace__________________Replace__________________Replace__________________")

def A_star(problem):

  node = Node(problem.Initial_state, 0, 0)
  f = F(problem, node, 'A_star')
  node = Node(problem.Initial_state, 0, 0, f=f)
  node.Set_f(f)
  frontier = []    #priority queue
  frontier.append((node.f,node))
  explored = []
  while True:
    if len(frontier) == 0:
      return "Failure"
    frontier.sort(reverse= True)
    node = frontier.pop()[1]
    print('POP:')
    print(node)
    print("f: ",node.f)
    print("__________________________________________________________________________________________________________________________________")
    if problem.Goal_test(node):
      print("PATH")
      s = node.Solution()
      return s

    explored.append(node.State)
    for action in problem.Action(node.State):
      child = Child_node(problem, node, action)
      child.Set_f(F(problem,child,'A_star'))
      if child.State not in explored and not child.exist_in(frontier,frontier_type= 'p_Q'):
        frontier.append((child.f, child))
      elif child.exist_in(frontier,frontier_type= 'p_Q'):
        Replace(frontier,child)
    print("EXPLORED:")
    print(explored)
    print("__________________________________________________________________________________________________________________________________")
    print("FRONTIER:")
    print(frontier)
    print("__________________________________________________________________________________________________________________________________")

prob = problem(maze, maze_Initial_state, maze_Goal_state) #(31*31)
# if you want test on simple maze(5*5) uncomment the following line
#prob = problem(simple_maze, simple_maze_Initial_state, simple_maze_Goal_state)
s = A_star(prob)
print(s)

print("____A* for a maze with two path____")
prob = problem(two_path_maze, two_path_maze_Initial_state, two_path_maze_Goal_state) #Two path maze
# if you want test on simple maze(5*5) uncomment the following line
#prob = problem(simple_maze, simple_maze_Initial_state, simple_maze_Goal_state)
s = A_star(prob)
print(s)